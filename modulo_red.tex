\section{Módulo Red}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{red}.

\textbf{géneros}: \TipoVariable{red}.

  ~

  \InterfazFuncion{IniciarRed}{}{red}
  [true]
  {$res$ $\igobs$ iniciarRed}
  [$O(1)$]
  [Crea una red nueva]
  []

  ~

  \InterfazFuncion{AgregarComputadora}{\Inout{r}{red}, \In{c}{compu} }{}
  [($r$ = $r_0$) $\land$ (($\forall$ $c'$: compu) ($c'$ $\in$ computadoras($r$) $\Rightarrow$  ip($c$) $\neq$  ip($c'$)))  ]
  {$r$ $\igobs$ agregarComputadora($r_0$, $c$)) }
  [$O(L + n)$]
  [Agrega un computadora a la red]
  []

  ~

  \InterfazFuncion{Conectar}{\Inout{r}{red}, \In{c}{compu}, \In{c'}{compu}, \In{i}{compu}, \In{i'}{compu}}{}
  [($r$ = $r_0$) $\land$ ($c$ $\in$ computadoras($r$)) $\land$ ($c'$ $\in$ computadoras(r)) $\land$ (ip($c$) $\neq$ ip($c'$)) \\
   $\land$ ($\neg$conectadas?($r$, $c$, $c'$)) $\land$ ($\neg$usaInterfaz?($r$, $c$, $i$) $\land$ $\neg$usaInterfaz?($r$, $c'$, $i'$))]
  {$r$ $\igobs$ conectar($r_0$, $c$, $i$, $c'$, $i'$))}
  [$O(L) ?$]
  [Conecta dos computadoras]
  []

  ~

  \InterfazFuncion{Computadoras}{\In{r}{red}}{conj(compu)}
  [true]  
  {$res$ = computadoras($r$)}
  [$O(1)$]

  ~

  \InterfazFuncion{Conectadas?}{\In{r}{red}, \In{c}{compu}, \In{c'}{compu}}{bool}
  [($c$ $\in$ computadoras($r$)) $\land$ ($c'$ $\in$ computadoras($r$))]
  {$res$ = conectadas?($r$, $c$, $c'$)}
  [$O(1)$]

  ~

  \InterfazFuncion{InterfazUsada}{\In{r}{red}, \In{c}{compu},  \In{c'}{compu}}{interfaz}
  [conectadas?($r$, $c$, $c'$)]
  {$res$ = interfazUsada($r$, $c$, $c'$)}
  [$O(?)$]

  ~

  \InterfazFuncion{Vecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}
  [$c$ $\in$ computadoras($r$)]
  {$res$ = vecinos($r$, $c$)}
  [$O(n)$]

  ~

  \InterfazFuncion{usaInterfaz?}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
  [$c$ $\in$ computadoras($r$)]
  {$res$ = usaInterfaz?($r$, $c$, $i$)}
  [$O(?)$]

  ~

  \InterfazFuncion{CaminosMinimos}{\In{r}{red}, \In{c}{compu}, \In{c'}{compu}}{conj(secu(compu))}
  [($c$ $\in$ computadoras($r$)) $\land$ ($c'$ $\in$ computadoras(r))]
  {$res$ = caminosMinimos($r$, $c$, $i$)}
  [$O(L)$]

  ~

  \InterfazFuncion{HayCamino?}{\In{r}{red}, \In{c}{compu}, \In{c'}{compu}}{bool}
  [($c$ $\in$ computadoras($r$)) $\land$ ($c'$ $\in$ computadoras(r))]
  {$res$ = hayCamino?($r$, $c$, $i$)}
  [$O(L)$]


\subsection{Representación}

  \subsubsection{Estructura}

    \begin{Estructura}{red}[estr]

      \begin{Tupla}[estr]
        \tupItem{compus}{conj(compu)}
        \tupItem{\\dns}{dicc$_{Trie}$(ip, nodoRed)}
      \end{Tupla}

      ~

      \begin{Tupla}[nodoRed]
        \tupItem{c}{puntero(compu)}
        \tupItem{\\caminos}{dicc$_{Trie}$(ip, conj(lista(compu)))}
        \tupItem{\\conexiones}{dicc$_{Lineal}$(interfaz, compu)}
      \end{Tupla}


    \end{Estructura}

\subsubsection{Invariante de Representación}
  \begin{enumerate}

  \item Todas las compus deben tener IPs distintas.

  \item Ninguna compu se conecta con si misma.

  \item Ninguna compu se conecta a otra a traves de dos interfaces distintas.

  \item El trie \TipoVariable{estr}.$dns$ apunta a un \TipoVariable{nodoRed}
        por cada elemento de $compus$.

  \item En cada \TipoVariable{nodoRed}, $c$ tiene que apuntar a un elemento de \TipoVariable{estr}.$compus$.

  \item Para cada \TipoVariable{nodoRed}, $caminos$ tiene como claves todas las
        IPs de las compus de la red, y los significados corresponden a todos los caminos
        mínimos desde la compu $c$ hacia la compu cuya IP es clave.

  \item \TipoVariable{nodoRed}.$conexiones$ contiene como claves todas las
        \TipoVariable{interfaz} usaconedas de la compu $c$ (que tienen que estar en $c$.$interfaces$)

  \end{enumerate}

  \Rep[estr][e]{

  %   ($\forall a$: string)($a \in e$.estaciones $<=>$ def?($a$, $e$.restricciones) ) $\land$ \\
  %   ($\forall c$, $s$: string)(def?($c$, $e$.restricciones) $\impluego$ \\
  %   ($\neg$def?($c$, obtener($c$, $e$.restricciones)) $\land$ \\
  %   (def?($s$, obtener($c$, $e$.restricciones)) $\impluego$ (def?($s$, $e$) $\land$ $s < c$)))) $\land$ \\
  %   ($\forall c$, $s$: string)(def?($c$, $e$.restricciones) $\impluego$ \\
  %   (def?($s$, obtener($c$, $e$.restricciones)) <=> <$c$, $s$> $\in$ $e$.sendas))}\mbox{}
  }

  \subsubsection{Función de Abstracción}

   \Abs[estr]{red}[e]{r}{
    % m.estaciones $\igobs$ e.estaciones $\land$ \\
    % ($\forall c$, $s$: string)(($c$ $\in$ estaciones($e$) $\land$ $s$ $\in$ estaciones($e$) $\land$ $c < s$) $\Rightarrow$ \\
                              % ((def?($s$, obtener($c$, $e$)) $\igobs$ conectadas?($c$, $s$, $m$)) $\yluego$ \\
                              % (def?($s$, obtener($c$, $e$)) $\impluego$ (obtener($s$, obtener($c$, $e$)) $\igobs$ restriccion($c$, $s$, $m$)))))
    }
  % }
\subsubsection{Función de Abstracción}




\subsection{Algoritmos}

\lstset{style=alg}
% La asignacion laQueMasEnvio <- NULL no se si esta bien porque si existe al menos una compu deberia devolver una, por mas que ninguna haya enviado todavia
\begin{lstlisting}[mathescape]
  '\alg{iIniciarRed}{}{red}'
    res.compus $\leftarrow$ Vacio() '\ote{1}'
    res.dns $\leftarrow$ Vacio() '\ote{1}'
  '\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iAgregarComputadora}{\Inout{r}{red}, \In{c}{compu}}{}'
    AgregoCompuNuevaAlResto(r.dns,c)  '\ote{n*L}'
    AgregarRapido(r.compus, c) '\ote{1}'  
    Definir(r.dns, compu.ip, Tupla<&c,Vacio(),Vacio()>) '\ote{L}'
    InicializarConjCaminos(r,c) '\ote{n}'
  '\ofi{O(n*L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{AgregoCompuNuevaAlResto}{\Inout{r}{red}, \In{c}{compu}}{}'
    itCompus:itConj(compu) $\leftarrow$ CrearIt(r.compus)   '\ote{1}'
    while HaySiguiente?(itCompus) do '\ote{1}'                                                   
      nr:nodoRed $\leftarrow$ Significado(r.dns,Siguiente(itCompus).ip) '\ote{L}'
      Definir(nr.caminos, c.ip, Vacio()) '\ote{L}'
      Avanzar(itCompus) '\ote{1}'
    end while  '\ote{n*L}'
  '\ofi{O(n*L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{InicializarConjCaminos}{\Inout{r}{red}, \In{c}{compu}}{}'
    itCompus:itConj(compu) $\leftarrow$ CrearIt(r.compus) '\ote{1}'
    cams:diccTrie(ip,conj(lista(compu))) $\leftarrow$
     Significado(r.dns, c.ip).caminos   '\ote{1}'
    while HaySiguiente?(itCompus) do   '\ote{1}'                                                 
      Definir(cams, Siguiente(itCompus).ip, Vacio())  '\ote{L}'
      Avanzar(itCompus) '\ote{1}'
    end while '\ote{n}'
  '\ofi{O(n)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iConectar}{\Inout{r}{red}, \In{c_0}{compu}, \In{c_1}{compu}, \In{i_0}{compu}, \In{i_1}{compu}}{}'
    nr0:nodoRed $\leftarrow$ Significado(r.dns, c0.ip) '\ote{L}'
    nr1:nodoRed $\leftarrow$ Significado(r.dns, c1.ip) '\ote{L}'
    DefinirRapido(rn0.conexiones, i0, nr1)'\ote{1}'
    DefinirRapido(nr1.conexiones, i1, nr0) '\ote{1}'
    CrearCaminosDelDNS(r) '\ote{n!*(n$^4$)}'
  '\ofi{O(n!*(n^4))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{CrearCaminosDelDNS}{\Inout{r}{red}}{}'
    itCompus:itConj(compu) $\leftarrow$ CrearIt(r.compus) '\ote{1}'
    while HaySiguiente?(itCompus) do  '\ote{1}'                                                  
      nr:nodoRed $\leftarrow$ Significado(d,Siguiente(itCompus).ip) '\ote{L}'
      AsignarCaminosMinimos(nr,r) '\ote{n!*(n$^3$)}'
      Avanzar(itCompus) '\ote{1}'
    end while '\ote{n!*(n$^4$)}'
  '\ofi{O(n!*(n^4))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{AsignarCaminosMinimos}{\Inout{nr}{nodoRed}}{}'
    itCompus:itConj(compu) $\leftarrow$ CrearIt(r.compus) '\ote{1}'
    while HaySiguiente?(itCompus) do  '\ote{1}'                                                
      Definir(nr.caminos, Siguiente(itCompus).ip '\ote{L}'
        CrearCaminosMinimos(nr, Siguiente(itCompus).ip)) '\ote{n!*(n$^2$)}'
      Avanzar(itCompus) '\ote{1}'
    end while '\ote{n!*(n$^3$}'
  '\ofi{O(n!*(n^3))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{CrearCaminosMinimos}{\In{desde}{nodoRed}, \In{hasta}{compu}}{conj(lista(compu))}'
    camMins:conj(lista(compu)) $\leftarrow$ Vacio() '\ote{1}'
    itCamMins:itConj(conj(lista(compu))) $\leftarrow$ CrearIt(camMins) '\ote{1}'
    pendientes:pila(nodoRed) $\leftarrow$ Vacia() '\ote{1}'
    ApilarConj(pendientes, Conexas(desde.conexiones))  '\ote{n}'
    visitados:conj(nodoRed) $\leftarrow$ Vacio() '\ote{1}'
    cam:lista(compu) $\leftarrow$ Vacia() '\ote{1}'
    AgregarAdelante(cam, *(desde.pc)) '\ote{1}'
    while $\neg$EsVacia?(pendientes) do  '\ote{1}'
      AgregarRapido(visitados,Siguiente(itNrs)) '\ote{1}'
      AgregarAdelante(cam, *(Siguiente(itNrs).pc)) '\ote{1}'
      if (Tope(pendientes).pc$\rightarrow$ip = hasta.ip) then '\ote{L}'
        if (Vacio?(camMins) $\lor$ (Longitud(cam) = Longitud(Siguiente
          (itCamMins)))) then '\ote{n}'
          AgregarRapido(camMins,cam) '\ote{1}'
        else
          if (Longitud(cam) < Longitud(Siguiente(itCamMins))) then '\ote{n}'
            camMins $\leftarrow$ Vacio() '\ote{1}'
            AgregarRapido(camMins,cam) '\ote{1}'
          endif '\ote{n}'
        endif '\ote{n}'
        Comienzo(cam) '\ote{1}'
      end if '\ote{n}'
      Desapilar(pendientes) '\ote{1}'
      nv:conj(nodoRed) $\leftarrow$ NoVisitadas(Tope(pendientes), visitados)  '\ote{n$^2$}'
      if(Vacia?(nv)) '\ote{(1}'
        Comienzo(cam)  '\ote{1}'
      else
        ApilarConj(pendientes, nv) '\ote{n}'
      end if '\ote{n}'
    end while '\ote{n! * n$^2$}'
  '\ofi{O(n!*(n^2))}'
\end{lstlisting}


\begin{lstlisting}[mathescape]
  '\alg{NoVisitadas}{\In{nr}{nodoRed}, \In{visitados}{conj(nodoRed)}}{conj(nodoRed)}'
    res $\leftarrow$  Vacio() '\ote{1}'
    itVecinos:itConj(nodoRed) $\leftarrow$ CrearIt(Conexas(nr.conexiones)) '\ote{n}'
    while HaySiguiente?(itVecinos) do  '\ote{1}'                                                   
      if($\neg$Pertenece?(visitados,Siguiente(itVecinos))) then '\ote{n}'
        AgregarRapido(res, Siguiente(itVecinos))  '\ote{1}'
      end if '\ote{n}'
      Avanzar(itVecinos) '\ote{1}'
    end while '\ote{n$^2$}'
  '\ofi{O(n^2)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{Conexas}{\In{conex}{dicc(interfaz,puntero(nodoRed))}}{conj(nodoRed)}'
    res $\leftarrow$ Vacio()  '\ote{1}'
    itVecinos :itDicc(interfaz, puntero(nodoRed))) $\leftarrow$ CrearIt(conex) '\ote{1}'
    while HaySiguiente?(itVecinos) do '\ote{1}'                                                    
      AgregarRapido(res, *SiguienteSignificado(itVecinos)) '\ote{1}'
      Avanzar(itVecinos) '\ote{1}'
    end while '\ote{n}'
  '\ofi{O(n)}'
\end{lstlisting}


\begin{lstlisting}[mathescape]
  '\alg{ApilarConj}{\Inout{pnr}{pila(nodoRed)}, \In{news}{conj(nodoRed)}}{}'
    it:itConj(nodoRed) $\leftarrow$ CrearIt(news) '\ote{1}'
    while HaySiguiente?(it) do  '\ote{1}'                                                   
      Apilar(pnr, Siguiente(it)) '\ote{1}'
      Avanzar(it) '\ote{1}'
    end while '\ote{n}'
  '\ofi{O(n)}'
\end{lstlisting}


\begin{lstlisting}[mathescape]
  '\alg{iComputadoras}{\In{r}{red}}{conj(compu)}'
    res  $\leftarrow$ r.compus  '\ote{1}'
  '\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iConectadas?}{\In{r}{red}, \In{c_0}{compu}, \In{c_1}{compu}}{bool}'
    nr0:nodoRed $\leftarrow$ Significado(r.dns, c0.ip) '\ote{L}' 
    it :itDicc(interfaz, puntero(nodoRed))) $\leftarrow$ CrearIt(nr0.conexiones) '\ote{1}' 
    res $\leftarrow$ false  '\ote{1}'
    while HaySiguiente?(it) do  '\ote{1}'
      if c1.ip = SiguienteSignificado(it)->pc->ip then  '\ote{1}'
        res $\leftarrow$ true   '\ote{1}'
      end if '\ote{1}'
      Avanzar(it) '\ote{1}'
    end while '\ote{n}'
  '\ofi{O(L + n)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iInterfazUsada}{\In{r}{red}, \In{c_0}{compu},  \In{c_1}{compu}}{interfaz}'
    nr0:nodoRed $\leftarrow$ Significado(r.dns, c0.ip)  '\ote{L}' 
    it :itDicc(itDicc(interfaz, puntero(nodoRed)) 
      $\leftarrow$ CrearIt(nr0.conexiones)  '\ote{1}' 
    while HaySiguiente?(it) do  '\ote{1}'  
      if c1.ip = SiguienteSignificado(it)->pc->ip then '\ote{1}'
        res $\leftarrow$ SiguienteClave(it)   '\ote{1}'
      end if '\ote{1}'
      Avanzar(it)   '\ote{1}'
    end while '\ote{n}'
  '\ofi{O(L + n)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iVecinos}{\In{r}{red}, \In{c}{compu}}{conj(compu)}'
    nr:nodoRed $\leftarrow$ Significado(r.dns, c.ip)  '\ote{L}'
    res:conj(compu) $\leftarrow$ Vacio()  '\ote{1}'
    it :itDicc(itDicc(interfaz, puntero(nodoRed))  
      $\leftarrow$ CrearIt(nr.conexiones)  '\ote{1}'      
    while HaySiguiente?(it) do  '\ote{1}'
      AgregarRapido(res,*(SiguienteSignificado(it)->pc))  '\ote{1}'  
      Avanzar(it)  '\ote{1}'
    end while '\ote{n}'  
  '\ofi{O(L + n)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iUsaInterfaz?}{\In{r}{red}, \In{c}{compu}, \In{i}{interfaz}}{bool}'
    nr:nodoRed $\leftarrow$ Significado(r.dns, c.ip)   '\ote{L}'
    res $\leftarrow$ Definido?(pnr.conexiones,i)  '\ote{n}'
  '\ofi{O(L + n)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{iCaminosMinimos}{\In{r}{red}, \In{c_0}{compu}, \In{c_1}{compu}}{conj(secu(compu))}'
    nr:nodoRed $\leftarrow$ Significado(r.dns, c0.ip) '\ote{L}'
    res $\leftarrow$  Significado(pnr.caminos, c1.ip) '\ote{L}'
  '\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{HayCamino?}{\In{r}{red}, \In{c_0}{compu}, \In{c_1}{compu}}{bool}'
    nr:nodoRed $\leftarrow$ Significado(r.dns, c0.ip)  '\ote{L}'
    res $\leftarrow$ $\neg$EsVacio?(Significado(pnr.caminos, c1.ip))  '\ote{L}'                                       
  '\ofi{O(L)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{Copiar}{\In{r}{red}}{red}'
    res:red $\leftarrow$ iIniciarRed '\ote{1}' 
    itCompus:itConj(compu) $\leftarrow$ CrearIt(r.compus) '\ote{1}'
     while HaySiguiente?(itCompus) do '\ote{1}'                                                 
      iAgregarComputadora(res,Siguiente(itCompus))  '\ote{n*L}'
      iConectar(res,Siguiente(itCompus)) '\ote{n!*(n$^4$)}'
    end while  '\ote{n!*(n$^5$)}'                              
  '\ofi{O(n!*(n^5))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
  '\alg{• = •}{\In{r_0}{red}, \In{r_1}{red}}{bool}'
    res $\leftarrow$ (r0.compus = r1.compus) $\land$ (r0.dns = r1.dns) '\ote{n$^2$}'                          
  '\ofi{O(n^2)}'
\end{lstlisting}


 

