\section{Módulo Diccionario AVL($\alpha$)}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$)}.

\textbf{géneros}: \TipoVariable{dicc$_{avl}$($\alpha$)}.

\subsubsection{Operaciones básicas de Diccionario AVL($\alpha$)}

	\InterfazFuncion{CrearDicc}{}{dicc$_{avl}$($\alpha$)}
	[true]
	{$res$ $\igobs$ vacío}%
	[$O(1)$]
	[Crea un diccionario vacío]
	[]

	~

	\InterfazFuncion{Definido?}{\In{c}{nat}, \In{d}{dicc$_{avl}$($\alpha$)})}{bool}
	[true]
	{$res$ $\igobs$ def?($c$, $d$)}
	[$O(log(\#claves(d)))$]
	[Devuelve \TipoVariable{true} si y sólo si la clave fue previamente definida en el diccionario]
	[]

	~

	\InterfazFuncion{Definir}{\In{c}{nat}, \In{s}{$\alpha$}, \Inout{d}{dicc$_{avl}$($\alpha$)}}{}
	[$d$ $\igobs$ $d_0$]
	{$d$ $\igobs$ definir($c$, $s$, $d_0$)}
	[$O(log(\#claves(d)) + copy(s))$]
	[Define la clave $c$ con el significado $s$ en $d$]
	[]

	~

	\InterfazFuncion{Obtener}{\In{c}{string}, \Inout{d}{dicc$_{avl}$($\alpha$)}}{$\alpha$}
	[def?($c$, $d$)]
	{alias($res$ $\igobs$ obtener($c$, $d$))}
	[$O(log(\#claves(d)))$]
	[Devuelve el significado correspondiente a la clave en el diccionario]
	[$res$ es modificable si y sólo si $d$ es modificable]

	~

	\InterfazFuncion{Mínimo}{\Inout{d}{dicc$_{avl}$($\alpha$)}}{$\alpha$}
	[\#claves($d$) > 0]
	{alias($res$ $\igobs$ obtener(claveMínima($d$), $d$))}
	[$O(log(\#claves(d)))$]
	[Devuelve el significado correspondiente a la clave de mínimo valor en el diccionario]
	[$res$ es modificable si y sólo si $d$ es modificable]

\subsubsection{Operaciones auxiliares del TAD}

\tadAlinearFunciones{darClaveMínima}{dicc(nat, $\alpha$)/d,conj(nat)/c}

	\tadOperacion{claveMínima}{dicc(nat, $\alpha$)/d}{nat}{$\#$claves(d) > 0}
	\tadOperacion{darClaveMínima}{dicc(nat, $\alpha$)/d,conj(nat)/c}{nat}{($\#$claves(d) > 0) $\land$ (c $\subseteq$ claves($d$))}

\tadAlinearAxiomas{darClaveMínima($d$, $c$)}

	\tadAxioma{claveMínima($d$)}{darClaveMínima($d$, claves($d$))}

	\tadAxioma{darClaveMínima($d$, $c$)}{
		\IF $\emptyset$?(sinUno($c$)) THEN
			dameUno($c$)
		ELSE {
			min(dameUno($c$), darClaveMínima($d$, sinUno($c$)))
			}
		FI
	}

\subsection{Representación}

	\subsubsection{Representación de dicc$_{avl}$($\alpha$)}

	\begin{Estructura}{dicc$_{avl}$($\alpha$)}[estr]
		\- \- \- \- donde \TipoVariable{estr} es \TipoVariable{puntero(nodoAvl)}

		\- \- \- \- donde \TipoVariable{nodoAvl} es
			\TipoVariable{tupla}(
				$clave$: \TipoVariable{nat},
				$data$: \TipoVariable{$\alpha$},
				$balance$: \TipoVariable{int},
				$hijos$: \TipoVariable{arreglo[2] de puntero(nodoAvl)}
			)
	\end{Estructura}



	\subsubsection{Invariante de Representación}
	  \begin{enumerate}
		\item{Se mantiene el invariante de árbol binario de búsqueda para las claves de los nodos.}
		\item{Cada nodo tiene $balance$ $\in$ \{-1, 0, 1 \} donde $balance$ es:$\newline$
			* 0 si el arbol esta balanciado $\newline$
			* 1 si existe un nodo en el ultimo nivel de balance tal que tenga un hijo a la izq$\newline$
			* -1 si existe un nodo en el ultimo nivel de balance tal que tenga un hijo a la der}
		\item{estr esta balaciado entero o  hasta (altura(estr) -1)  esta balaciado }	
		\item{Todas las claves son distintas.}

	  \end{enumerate}

	\tadAlinearFunciones{Rep}{estr}
	\tadAlinearAxiomas{Rep(e)}

	\Rep[estr][e]{ esABB($e$) $\land$ balanciadoBien($e$) $\land$ clavesDistintas($e$, vacío)}


		\tadAlinearFunciones{alturaBienwachooooo}{puntero(nodoAvl), conj(nat)}
		\tadAlinearAxiomas{clavesDistintas($n$, $cs$)}

		~

		\tadOperacion{esABB}{puntero(nodoAvl)}{bool}{}
		\tadOperacion{balanciadoBien}{puntero(nodoAvl)}{bool}{}
		\tadOperacion{clavesDistintas(}{puntero(nodoAvl), conj(nat)}{bool}{}

		~

		\tadAxioma{esABB($n$)}{
			($n$ $\neq$ NULL) $\impluego$ ( \\
				((prim($n$.hijos) $\neq$ NULL) $\impluego$ ($n$.clave $>$ prim($n$.hijos) $\land$ esABB(prim($n$.hijos)))) $\land$ \\
				(( ult($n$.hijos) $\neq$ NULL) $\impluego$ ($n$.clave $<$ ult($n$.hijos) $\land$  esABB(ult($n$.hijos)))))
		}

		\tadAxioma{balanciadoBien($n$)}{
			(balanceado($n$) $\lor$ balanceado(hastaAltura($n$,altura($n$)-1))) $\yluego$
			($n$ $\neq$ NULL) $\impluego$ (\\
			 \IF ((prim($n$.hijos) $\neq$ NULL) $\land$ (ult($n$.hijos) $\neq$ NULL)) THEN
			 	balanciadoBien(prim($n$.hijos)) $\land$ balanciadoBien(ult($n$.hijos)))
			 ELSE{
			 	\IF (prim($n$.hijos) $\neq$ NULL) THEN
			 		$n$.balance = 1
			 	ELSE{
			 		\IF (prim($n$.hijos) $\neq$ NULL) THEN
			 			$n$.balance = -1
			 		ELSE
			 			$n$.balance = 0
			 		FI	
			 	} FI
			c
			} FI
			) $\land$
			
		}

		\tadAxioma{clavesDistintas($n$, $cs$)}{
		($n$ $\neq$ NULL) $\impluego$ \\
				\- $n$.clave $\notin$ $cs$ $\land$ \\
				clavesDistintas(prim($n$.hijos), Ag($n$.clave, $cs$)) $\land$ \\
				clavesDistintas(ult($n$.hijos), Ag($n$.clave, $cs$))

		}

	\subsubsection{Función de Abstracción}
	  \tadAlinearFunciones{Abs}{Estr/e}
	  \Abs[estr]{dicc(nat, $\alpha$)}[e]{d}{
		auxAbs(e, vacío)
	}

	~

	\tadAlinearFunciones{auxAbs}{puntero(nodoAvl), dicc(nat;\ $\alpha$)}
	\tadAlinearAxiomas{auxAbs($n$, $d$)}

	\tadOperacion{auxAbs}{puntero(nodoAvl), dicc(nat;\ $ \alpha$)}{dicc(nat, $\alpha$)}{}

	\tadAxioma{auxAbs($n$, $d$)}{
		\IF $n$ = NULL THEN
			$d$
		ELSE definir($n$.clave, $n$.data, auxAbs(prim($n$.hijos), auxAbs(ult($n$.hijos), $d$)))
		FI

	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos}

\lstset{style=alg,columns=fixed,basewidth=.5em}

\begin{lstlisting}[mathescape]
'\alg{iInsertar}{\Inout{puntero(nodoAvl)}{tree}, \In{nat}{c}, \In{\alpha}{s}}{}'
    if (tree->root == NULL) then
    {
        tree->root = make_node(data);

        if (tree->root == NULL)
        {
            return 0;
        }
    }
 
'\ofi{O(1)}'
\end{lstlisting}


\lstset{style=alg,columns=fixed,basewidth=.5em}

\begin{lstlisting}[mathescape]
'\alg{iVacío}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iDefinir}{\Inout{p}{puntero(nodoAvl)}, \Inout{clave}{nat}, \Inout{significado}{alpha}}{}'
	padre: puntero(nodoAvl) $\leftarrow$ p '\ote{1}'
	nuevo: nodoAvl $\leftarrow$ {clave: clave, data: significado, altura: 0, hijos: [NULL, NULL]} '\ote{copy(significado)}'
	bool: buscarMas $\leftarrow$ true '\ote{1}'
	dir: int

	while (buscarMas) do '\ote{1}'
		if (padre.clave = clave) then '\ote{1}'
			padre.data $\leftarrow$ significado '\ote{copy(significado)}'
			buscarMas $\leftarrow$ false '\ote{1}'
		else
			if (padre.clave > clave) then '\ote{1}'
				dir $\leftarrow$ 0 '\ote{1}'
			else
				dir $\leftarrow$ 1 '\ote{1}'
			end if

		    if (padre.hijos[dir] = NULL) then '\ote{1}'
				padre.hijos[dir] $\leftarrow$ &nuevo '\ote{1}'
				balancear(p)
				buscarMas $\leftarrow$ false '\ote{1}'
			else
				padre $\leftarrow$ padre.hijos[dir] '\ote{1}'
			end if

		end if
	end while '\ote{p.altura}'
'\ofi{O(p.altura + copy(significado))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iBorrar}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iDefinido?}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iObtener}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iClaves}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{Mínimo}{\In{dicc_{avl}(\alpha)}{d}}{$\alpha$}'

	actual:puntero(nodoAvl) $\leftarrow$ d
	hijoMenor:puntero(nodoAvl)
	done:bool $\leftarrow$ false

	while (!done) do
		hijoMenor $\leftarrow$ (actual$\rightarrow$hijos[0])

		if (hijoMenor != NULL) then
			actual $\leftarrow$ hijoMenor
		else
			res $\leftarrow$ (actual$\rightarrow$data)
			done $\leftarrow$ true
		end if
	end while
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{Inorder}{\In{dicc_{avl}(\alpha)}{n}}{lista(tupla(clave, significado))}'
	c:puntero(nodoAvl) $\leftarrow$ n
	p:pila(puntero(nodoAvl)) $\leftarrow$ Vacia()
	done:bool $\leftarrow$ false
	res $\leftarrow$ Vacia()

	while (!done) do
		if (c != NULL) then
			Apilar(p, c)
			c $\leftarrow$ (c$\rightarrow$hijos[0])
		else
			if !EsVacia?(p) then
				AgregarAtras(res, << Tope(p)->clave, Tope(p)->data >>)
				c $\leftarrow$ Tope(p)$\rightarrow$hijos[1]
			else
				done $\leftarrow$ true
			end if
		end if
	end while
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{• = •}{\In{dicc_{avl}(\alpha)}{d1}, \In{dicc_{avl}(\alpha)}{d2}}{bool}'
	res $\leftarrow$ Inorder(d1) = Inorder(d2)
\end{lstlisting}
