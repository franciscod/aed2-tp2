\section{Módulo dicc$_{avl}$($\alpha$)}

\subsection{Interfaz}

\textbf{se explica con}: \tadNombre{Diccionario(nat, $\alpha$)}.

\textbf{géneros}: \TipoVariable{dicc$_{avl}$($\alpha$)}.

\subsubsection{Operaciones básicas de dicc$_{avl}$($\alpha$)}

	\InterfazFuncion{CrearDicc}{}{dicc$_{avl}$($\alpha$)}
	[true]
	{$res$ $\igobs$ vacío}%
	[$O(1)$]
	[Crea un diccionario vacío]
	[]

	~

	\InterfazFuncion{Definido?}{\In{c}{nat}, \In{d}{dicc$_{avl}$($\alpha$)})}{bool}
	[true]
	{$res$ $\igobs$ def?($c$, $d$)}
	[$O(log(\#claves(d)))$]
	[Devuelve \TipoVariable{true} si y sólo si la clave fue previamente definida en el diccionario]
	[]

	~

	\InterfazFuncion{Definir}{\In{c}{nat}, \In{s}{$\alpha$}, \Inout{d}{dicc$_{avl}$($\alpha$)}}{}
	[$d$ $\igobs$ $d_0$]
	{$d$ $\igobs$ definir($c$, $s$, $d_0$)}
	[$O(log(\#claves(d)) + copy(s))$]
	[Define la clave $c$ con el significado $s$ en $d$]
	[]

	~

	\InterfazFuncion{Obtener}{\In{c}{string}, \Inout{d}{dicc$_{avl}$($\alpha$)}}{$\alpha$}
	[def?($c$, $d$)]
	{alias($res$ $\igobs$ obtener($c$, $d$))}
	[$O(log(\#claves(d)))$]
	[Devuelve el significado correspondiente a la clave en el diccionario]
	[$res$ es modificable si y sólo si $d$ es modificable]

	~

	\InterfazFuncion{Mínimo}{\Inout{d}{dicc$_{avl}$($\alpha$)}}{$\alpha$}
	[\#claves($d$) > 0]
	{alias($res$ $\igobs$ obtener(claveMínima($d$), $d$))}
	[$O(log(\#claves(d)))$]
	[Devuelve el significado correspondiente a la clave de mínimo valor en el diccionario]
	[$res$ es modificable si y sólo si $d$ es modificable]

\subsubsection{Operaciones auxiliares del TAD}

\tadAlinearFunciones{darClaveMínima}{dicc(nat, $\alpha$)/d,conj(nat)/c}

	\tadOperacion{claveMínima}{dicc(nat, $\alpha$)/d}{nat}{$\#$claves(d) > 0}
	\tadOperacion{darClaveMínima}{dicc(nat, $\alpha$)/d,conj(nat)/c}{nat}{($\#$claves(d) > 0) $\land$ (c $\subseteq$ claves($d$))}

\tadAlinearAxiomas{darClaveMínima($d$, $c$)}

	\tadAxioma{claveMínima($d$)}{darClaveMínima($d$, claves($d$))}

	\tadAxioma{darClaveMínima($d$, $c$)}{
		\IF $\emptyset$?(sinUno($c$)) THEN
			dameUno($c$)
		ELSE {
			min(dameUno($c$), darClaveMínima($d$, sinUno($c$)))
			}
		FI
	}

\subsection{Representación}

	\subsubsection{Representación de dicc$_{avl}$($\alpha$)}

	\begin{Estructura}{dicc$_{avl}$($\alpha$)}[estr]
		\- \- \- \- donde \TipoVariable{estr} es \TipoVariable{puntero(nodoAvl)}

		\- \- \- \- donde \TipoVariable{nodoAvl} es
			\TipoVariable{tupla}(
				$clave$: \TipoVariable{int},
				$data$: \TipoVariable{$\alpha$},
				$altura$: \TipoVariable{int},
				$hijos$: \TipoVariable{arreglo[2] de puntero(nodoAvl)}
			)
	\end{Estructura}



	\subsubsection{Invariante de Representación}
	  \begin{enumerate}
		\item{Se mantiene el invariante de árbol binario de búsqueda para las claves de los nodos.}
		\item{Cada nodo tiene en su $altura$ el máximo de la altura de sus hijos + 1 (las hojas tienen altura 0).}
		\item{Todas las claves son distintas.}
	  \end{enumerate}

	\tadAlinearFunciones{Rep}{estr}
	\tadAlinearAxiomas{Rep(e)}

	\Rep[estr][e]{ esABB($e$) $\land$ alturaBien($e$) $\land$ clavesDistintas($e$, vacío)}


		\tadAlinearFunciones{alturaBienwachooooo}{puntero(nodoAvl), conj(nat)}
		\tadAlinearAxiomas{clavesDistintas($n$, $cs$)}

		~

		\tadOperacion{esABB}{puntero(nodoAvl)}{bool}{}
		\tadOperacion{alturaBien}{puntero(nodoAvl)}{bool}{}
		\tadOperacion{clavesDistintas}{puntero(nodoAvl), conj(nat)}{bool}{}

		~

		\tadAxioma{esABB($n$)}{
			($n$ $\neq$ NULL) $\impluego$ ( \\
				((prim($n$.hijos) $\neq$ NULL) $\impluego$ ($n$.clave $>$ prim($n$.hijos) $\land$ esABB(prim($n$.hijos)))) $\land$ \\
				(( ult($n$.hijos) $\neq$ NULL) $\impluego$ ($n$.clave $<$ ult($n$.hijos) $\land$  esABB(ult($n$.hijos)))))
		}

		\tadAxioma{alturaBien($n$)}{

			($n$ $\neq$ NULL) $\impluego$ ($n$.altura = max( \\
			\IF (prim($n$.hijos) $\neq$ NULL) THEN
				prim($n$.hijos).altura + 1
			ELSE
				0
			FI, \\
			\IF (ult($n$.hijos) $\neq$ NULL) THEN
				ult($n$.hijos).altura + 1
			ELSE
				0
			FI) $\land$

			alturaBien(prim($n$.hijos)) $\land$ alturaBien(ult($n$.hijos)))
		}

		\tadAxioma{clavesDistintas($n$, $cs$)}{
		($n$ $\neq$ NULL) $\impluego$ \\
				\- $n$.clave $\notin$ $cs$ $\land$ \\
				clavesDistintas(prim($n$.hijos), Ag($n$.clave, $cs$)) $\land$ \\
				clavesDistintas(ult($n$.hijos), Ag($n$.clave, $cs$))

		}

	\subsubsection{Función de Abstracción}
	  \tadAlinearFunciones{Abs}{Estr/e}
	  \Abs[estr]{dicc(nat, $\alpha$)}[e]{d}{
		auxAbs(e, vacío)
	}

	~

	\tadAlinearFunciones{auxAbs}{puntero(nodoAvl), dicc(nat;\ $\alpha$)}
	\tadAlinearAxiomas{auxAbs($n$, $d$)}

	\tadOperacion{auxAbs}{puntero(nodoAvl), dicc(nat;\ $ \alpha$)}{dicc(nat, $\alpha$)}{}

	\tadAxioma{auxAbs($n$, $d$)}{
		\IF $n$ = NULL THEN
			$d$
		ELSE definir($n$.clave, $n$.data, auxAbs(prim($n$.hijos), auxAbs(ult($n$.hijos), $d$)))
		FI

	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmos}

\lstset{style=alg,columns=fixed,basewidth=.5em}

\begin{lstlisting}[mathescape]
'\alg{iVacío}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iDefinir}{\Inout{p}{puntero(nodoAvl)}, \Inout{clave}{nat}, \Inout{significado}{alpha}}{}'
	padre: puntero(nodoAvl) $\leftarrow$ p '\ote{1}'
	nuevo: nodoAvl $\leftarrow$ {clave: clave, data: significado, altura: 0, hijos: [NULL, NULL]} '\ote{copy(significado)}'
	bool: buscarMas $\leftarrow$ true '\ote{1}'
	dir: int

	while (buscarMas) do '\ote{1}'
		if (padre.clave = clave) then '\ote{1}'
			padre.data $\leftarrow$ significado '\ote{copy(significado)}'
			buscarMas $\leftarrow$ false '\ote{1}'
		else
			if (padre.clave > clave) then '\ote{1}'
				dir $\leftarrow$ 0 '\ote{1}'
			else
				dir $\leftarrow$ 1 '\ote{1}'
			end if

		    if (padre.hijos[dir] = NULL) then '\ote{1}'
				padre.hijos[dir] $\leftarrow$ &nuevo '\ote{1}'
				balancear(p)
				buscarMas $\leftarrow$ false '\ote{1}'
			else
				padre $\leftarrow$ padre.hijos[dir] '\ote{1}'
			end if

		end if
	end while '\ote{p.altura}'
'\ofi{O(p.altura + copy(significado))}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iBorrar}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iDefinido?}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iObtener}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}

\begin{lstlisting}[mathescape]
'\alg{iClaves}{}{puntero(nodoAvl)}'
	res $\leftarrow$ NULL		 '\ote{1}'
'\ofi{O(1)}'
\end{lstlisting}
